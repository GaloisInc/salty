{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE OverloadedStrings #-}

import Options

import CodeGen.Dot (dotFSM)
import CodeGen.Java (Package,javaFSM)
import CodeGen.Python (pythonFSM)
import Message (ppError)
import Opt (opt)
import Opt.Simpl (simp)
import PP (pp)
import Scope.Check
import Scope.Name (emptySupply)
import Slugs (runSlugs,parseSlugsJSON,parseSlugsOut,FSM)
import Syntax.AST
import Syntax.Parser
import TypeCheck

import           Control.Exception (catch,IOException)
import           Control.Monad (when)
import qualified Data.Aeson as JSON
import qualified Data.Aeson.Encode.Pretty as JSON
import qualified Data.ByteString.Lazy.Char8 as LB
import qualified Data.Map.Strict as Map
import           Data.Maybe (mapMaybe)
import qualified Data.Text.Lazy as L
import qualified Data.Text.Lazy.IO as L
import           System.Directory (createDirectoryIfMissing)
import           System.Exit (exitFailure)
import           System.FilePath (takeDirectory,(</>))
import           Text.Location (thing)
import           Text.Show.Pretty (ppShow)

main :: IO ()
main  =
  do opts <- parseOptions

     input <-
       case optInput opts of
         Just inp -> return inp
         Nothing  -> do putStrLn "No input specified"
                        exitFailure

     fsm <- genFSM opts input

     case optJava opts of
       Just pkg -> writePackage opts (javaFSM pkg fsm)
       Nothing  -> return ()

     when (optPython opts) (writePackage opts (pythonFSM fsm))

     when (optDot opts) (writePackage opts (dotFSM fsm))

genFSM :: Options -> Input -> IO FSM

genFSM opts (InpSpec path) =
  do bytes <- L.readFile path

     pCont <-
       case parseController path bytes of
         Right p  -> return p
         Left err -> do print (ppError err)
                        exitFailure

     when (optDumpParsed opts) (putStrLn (ppShow pCont))

     when (optAnnotations opts) (dumpAnnotations pCont)

     (scCont,scSup) <-
       case scopeCheck emptySupply pCont of
         Right sc  -> return sc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     (tcCont,tcSup) <-
       case typeCheck scSup scCont of
         Right tc  -> return tc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     when (optDumpCore opts) (print (pp tcCont))

     let exCont = expand tcCont
     when (optDumpExpanded opts) (print (pp exCont))

     -- sanity check the expanded module
     -- NORE: sanity checking requires that expand has been called.
     sMsgs <- sanityCheck (optDumpSanity opts) (optZ3 opts) exCont
     mapM_ (print . ppSanityMessage) sMsgs
     when (not (null (sanityErrors sMsgs))) exitFailure

     when (optDumpSimp opts) (print (pp (simp exCont)))

     (oCont,_) <-
       if optOptLevel opts >= 1 
          then do let (oCont,oSup) = opt tcSup exCont
                  when (optDumpOpt opts) (print (pp oCont))
                  return (oCont,oSup)

          else return (exCont,tcSup)

     mb <- runSlugs (optDumpSpec opts) (optSlugs opts) oCont `catch` \ e ->
       do let _ = e :: IOException
          putStrLn "Failed to run slugs. Is SLUGS set?"
          exitFailure

     case mb of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Unrealizable"
                      exitFailure

genFSM opts (InpJSON path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     json <- LB.readFile path

     case parseSlugsJSON path numInputs json of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs JSON output"
                      exitFailure

genFSM opts (InpSlugsOut path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     slugsout <- LB.readFile path

     case parseSlugsOut path numInputs slugsout of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs output"
                      exitFailure


-- | Write out a package generated by one of the code generators.
writePackage :: Options -> Package -> IO ()
writePackage opts pkg = mapM_ writeClass (Map.toList pkg)
  where
  prefix = case optOutDir opts of
             Just dir -> dir
             Nothing  -> ""

  writeClass (file,doc) =
    do let outFile = prefix </> file
       putStrLn ("Writing " ++ outFile)
       createDirectoryIfMissing True (takeDirectory outFile)

       writeFile outFile (show doc)


dumpAnnotations :: Controller PName -> IO ()
dumpAnnotations Controller { .. } =
  LB.putStrLn $ JSON.encodePretty
              $ JSON.toJSON
              $ mapMaybe dump cDecls

  where

  dump (TDFun Fun { .. }) = jsonAnnotation <$> fAnn
  dump (TDLoc loc)        = dump (thing loc)
  dump _                  = Nothing

jsonAnnotation :: Ann -> JSON.Value

jsonAnnotation (AnnApp f xs) =
  JSON.object [ "name" JSON..= f
              , "args" JSON..= map jsonAnnotation xs ]

jsonAnnotation (AnnArr xs) =
  JSON.toJSON (map jsonAnnotation xs)

jsonAnnotation (AnnObj xs) =
  JSON.object [ L.toStrict l JSON..= jsonAnnotation x | (l,x) <- xs ]

jsonAnnotation (AnnSym sym) =
  JSON.toJSON sym

jsonAnnotation (AnnStr str) =
  JSON.toJSON str

jsonAnnotation (AnnCode ty str) =
  JSON.object [ "language" JSON..= ty
              , "code"     JSON..= str ]

jsonAnnotation (AnnLoc loc) =
  jsonAnnotation (thing loc)
