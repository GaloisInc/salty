{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE OverloadedStrings #-}

import Options

import           CodeGen.Dot (dotFSM)
import           CodeGen.Java (Package,javaFSM)
import           CodeGen.Python (pythonFSM)
import           Message (ppError)
import           Opt (opt)
import           Opt.Simpl (simp)
import           PP (pp)
import           Scope.Check
import           Scope.Name (Name,emptySupply,nameText)
import           Slugs (runSlugs,parseSlugsJSON,parseSlugsOut,FSM)
import           Syntax.AST
import           Syntax.Parser
import           TypeCheck
import qualified TypeCheck.AST as TC

import           Control.Exception (catch,IOException)
import           Control.Monad (when)
import qualified Data.Aeson as JSON
import qualified Data.Aeson.Encode.Pretty as JSON
import qualified Data.ByteString.Lazy.Char8 as LB
import qualified Data.Foldable as F
import qualified Data.Map.Strict as Map
import           Data.Maybe (mapMaybe)
import qualified Data.Text.Lazy as L
import qualified Data.Text.Lazy.IO as L
import           System.Directory (createDirectoryIfMissing)
import           System.Exit (exitFailure)
import           System.FilePath (takeDirectory,(</>))
import           Text.Location (thing)
import           Text.Show.Pretty (ppShow)

main :: IO ()
main  =
  do opts <- parseOptions

     input <-
       case optInput opts of
         Just inp -> return inp
         Nothing  -> do putStrLn "No input specified"
                        exitFailure

     fsm <- genFSM opts input

     case optJava opts of
       Just pkg -> writePackage opts (javaFSM pkg fsm)
       Nothing  -> return ()

     when (optPython opts) (writePackage opts (pythonFSM fsm))

     when (optDot opts) (writePackage opts (dotFSM fsm))

genFSM :: Options -> Input -> IO FSM

genFSM opts (InpSpec path) =
  do bytes <- L.readFile path

     pCont <-
       case parseController path bytes of
         Right p  -> return p
         Left err -> do print (ppError err)
                        exitFailure

     when (optDumpParsed opts) (putStrLn (ppShow pCont))

     (scCont,scSup) <-
       case scopeCheck emptySupply pCont of
         Right sc  -> return sc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     (tcCont,tcSup) <-
       case typeCheck scSup scCont of
         Right tc  -> return tc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     when (optAnnotations opts) (dumpAnnotations tcCont)

     when (optDumpCore opts) (print (pp tcCont))

     let exCont = expand tcCont
     when (optDumpExpanded opts) (print (pp exCont))

     -- sanity check the expanded module
     -- NORE: sanity checking requires that expand has been called.
     sMsgs <- sanityCheck (optDumpSanity opts) (optZ3 opts) exCont
     mapM_ (print . ppSanityMessage) sMsgs
     when (not (null (sanityErrors sMsgs))) exitFailure

     when (optDumpSimp opts) (print (pp (simp exCont)))

     (oCont,_) <-
       if optOptLevel opts >= 1 
          then do let (oCont,oSup) = opt tcSup exCont
                  when (optDumpOpt opts) (print (pp oCont))
                  return (oCont,oSup)

          else return (exCont,tcSup)

     mb <- runSlugs (optDumpSpec opts) (optSlugs opts) oCont `catch` \ e ->
       do let _ = e :: IOException
          putStrLn "Failed to run slugs. Is SLUGS set?"
          exitFailure

     case mb of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Unrealizable"
                      exitFailure

genFSM opts (InpJSON path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     json <- LB.readFile path

     case parseSlugsJSON path numInputs json of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs JSON output"
                      exitFailure

genFSM opts (InpSlugsOut path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     slugsout <- LB.readFile path

     case parseSlugsOut path numInputs slugsout of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs output"
                      exitFailure


-- | Write out a package generated by one of the code generators.
writePackage :: Options -> Package -> IO ()
writePackage opts pkg = mapM_ writeClass (Map.toList pkg)
  where
  prefix = case optOutDir opts of
             Just dir -> dir
             Nothing  -> ""

  writeClass (file,doc) =
    do let outFile = prefix </> file
       putStrLn ("Writing " ++ outFile)
       createDirectoryIfMissing True (takeDirectory outFile)

       writeFile outFile (show doc)


dumpAnnotations :: TC.Controller -> IO ()
dumpAnnotations TC.Controller { .. } =
  LB.putStrLn $ JSON.encodePretty
              $ JSON.toJSON
              $ funs ++ enums ++ stateVars

  where

  funs = mapMaybe dumpFun (concatMap F.toList cFuns)

  dumpFun TC.Fun { .. } =
    do ann <- fAnn
       return $ JSON.object [ "macro"      JSON..= jsonName fName
                            , "annotation" JSON..= jsonAnnotation ann ]

  enums = mapMaybe dumpEnum cEnums

  dumpEnum TC.EnumDef { .. } = 
    do ann <- eAnn
       return $ JSON.object [ "enum"       JSON..= jsonName eName
                            , "annotation" JSON..= jsonAnnotation ann ]

  stateVars = mapMaybe (dumpStateVar "input")  cInputs
           ++ mapMaybe (dumpStateVar "output") cOutputs

  dumpStateVar ty = \ TC.StateVar { .. } ->
    do ann <- svAnn
       return $ JSON.object [ ty           JSON..= jsonName svName
                            , "annotation" JSON..= jsonAnnotation ann ]



jsonAnnotation :: Ann -> JSON.Value
jsonAnnotation  = go
  where
  go (AnnApp f xs) =
    JSON.object [ "name" JSON..= f
                , "args" JSON..= map go xs ]

  go (AnnArr xs) =
    JSON.toJSON (map go xs)

  go (AnnObj xs) =
    JSON.object [ L.toStrict l JSON..= go x | (l,x) <- xs ]

  go (AnnSym sym) =
    JSON.toJSON sym

  go (AnnStr str) =
    JSON.toJSON str

  go (AnnCode ty str) =
    JSON.object [ "language" JSON..= ty
                , "code"     JSON..= str ]

  go (AnnLoc loc) =
    go (thing loc)


jsonName :: Name -> JSON.Value
jsonName n = JSON.toJSON (nameText n)
