{-# LANGUAGE RecordWildCards #-}

import Options

import CodeGen.Dot (dotFSM)
import CodeGen.Java (Package,javaFSM)
import CodeGen.Python (pythonFSM)
import Message (ppError)
import Opt (opt)
import Opt.Simpl (simp)
import PP (pp)
import Scope.Check
import Scope.Name (emptySupply)
import Slugs (runSlugs,parseSlugsJSON,parseSlugsOut,FSM)
import Syntax.Parser
import TypeCheck

import           Control.Exception (catch,IOException)
import           Control.Monad (when)
import qualified Data.ByteString.Lazy as LB
import qualified Data.Map.Strict as Map
import qualified Data.Text.Lazy.IO as L
import           System.Directory (createDirectoryIfMissing)
import           System.Exit (exitFailure)
import           System.FilePath (takeDirectory,(</>))
import           Text.Show.Pretty (ppShow)

main :: IO ()
main  =
  do opts <- parseOptions

     input <-
       case optInput opts of
         Just inp -> return inp
         Nothing  -> do putStrLn "No input specified"
                        exitFailure

     fsm <- genFSM opts input

     case optJava opts of
       Just pkg -> writePackage opts (javaFSM pkg fsm)
       Nothing  -> return ()

     when (optPython opts) (writePackage opts (pythonFSM fsm))

     when (optDot opts) (writePackage opts (dotFSM fsm))

genFSM :: Options -> Input -> IO FSM

genFSM opts (InpSpec path) =
  do bytes <- L.readFile path

     pCont <-
       case parseController path bytes of
         Right p  -> return p
         Left err -> do print (ppError err)
                        exitFailure

     when (optDumpParsed opts) (putStrLn (ppShow pCont))

     (scCont,scSup) <-
       case scopeCheck emptySupply pCont of
         Right sc  -> return sc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     (tcCont,tcSup) <-
       case typeCheck scSup scCont of
         Right tc  -> return tc
         Left errs -> do mapM_ (print . ppError) errs
                         exitFailure

     when (optDumpCore opts) (print (pp tcCont))

     sMsgs <- sanityCheck (optDumpSanity opts) (optZ3 opts) tcCont
     mapM_ (print . ppSanityMessage) sMsgs
     when (not (null (sanityErrors sMsgs))) exitFailure

     let exCont = expand tcCont
     when (optDumpExpanded opts) (print (pp exCont))

     when (optDumpSimp opts) (print (pp (simp exCont)))

     (oCont,_) <-
       if optOptLevel opts >= 1 
          then do let (oCont,oSup) = opt tcSup exCont
                  when (optDumpOpt opts) (print (pp oCont))
                  return (oCont,oSup)

          else return (exCont,tcSup)

     mb <- runSlugs (optDumpSpec opts) (optSlugs opts) oCont `catch` \ e ->
       do let _ = e :: IOException
          putStrLn "Failed to run slugs. Is SLUGS set?"
          exitFailure

     case mb of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Unrealizable"
                      exitFailure

genFSM opts (InpJSON path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     json <- LB.readFile path

     case parseSlugsJSON path numInputs json of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs JSON output"
                      exitFailure

genFSM opts (InpSlugsOut path) =
  do numInputs <-
       case optInputLen opts of
         Just len -> return len
         Nothing  -> do putStrLn "`--length` flag is required when consuming raw slugs output"
                        exitFailure

     slugsout <- LB.readFile path

     case parseSlugsOut path numInputs slugsout of
       Just fsm -> return fsm
       Nothing  -> do putStrLn "Failed to parse slugs output"
                      exitFailure


-- | Write out a package generated by one of the code generators.
writePackage :: Options -> Package -> IO ()
writePackage opts pkg = mapM_ writeClass (Map.toList pkg)
  where
  prefix = case optOutDir opts of
             Just dir -> dir
             Nothing  -> ""

  writeClass (file,doc) =
    do let outFile = prefix </> file
       putStrLn ("Writing " ++ outFile)
       createDirectoryIfMissing True (takeDirectory outFile)

       writeFile outFile (show doc)
