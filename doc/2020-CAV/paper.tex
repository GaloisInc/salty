\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{xtab}
\usepackage{stmaryrd}
\usepackage{amsmath, amssymb}
\usepackage{listings}
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

% OUR MACROS
\input{macros}

\begin{document}
\lstset{language=Ada}
\lstset{basicstyle=\ttfamily}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TITLE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\title{End-to-End Verification of Initial and Transition Properties of GR(1) Designs in SPARK\thanks{Supported by AFRL contract FA8650-16-C-2642 and AFOSR grant RQCOR20-35.}}
%
\titlerunning{End-to-End Verification of GR(1) Designs in SPARK}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Laura Humphrey\inst{1}\orcidID{0000-1111-2222-3333} \and
James Hamil\inst{2}\orcidID{1111-2222-3333-4444} \and
Joffrey Heugenot\inst{3}\orcidID{2222--3333-4444-5555}}
%
\authorrunning{L. Humphrey et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Air Force Research Laboratory, WPAFB, OH 45433, USA \\
\email{laura.humphrey@us.af.mil} \and
LinQuest Corp., Beavercreek, OH 45431, USA \\
\email{james.hamil@ctr.us.af.mil}  \and
AdaCore, F-75009 Paris, France \\
 \email{huguet@adacore.com}}
%
\maketitle              % typeset the header of the contribution
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ABSTRACT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
%The abstract should briefly summarize the contents of the paper in 150--250 words.
Manually designing control logic for reactive systems is time-consuming and error-prone. 
An alternative is to automatically generate controllers using ``correct-by-construction'' synthesis approaches. 
Recently, there has been interest in synthesis from Generalized Reactivity(1) or GR(1) specifications, 
since the required computational complexity is relatively low, and several tools now exist for GR(1) synthesis.
However, while these tools implement synthesis approaches that are theoretically ``correct-by-construction,'' 
errors in tool implementation can still lead to errors in synthesized controllers. 
We are therefore interested in ``end-to-end'' verification of synthesized controllers with respect to their original GR(1) specifications.
Toward this end we have modified Salty -- a tool that produces executable software implementations of controllers 
from GR(1) specifications in a variety of programming languages -- to produce implementations in SPARK.
SPARK is both a language and associated set of verification tools, so it has the potential to enable the ``end-to-end'' verification we desire.  
In this paper, we discuss our experience to date using SPARK to implement controllers and verify them against 
a subset of properties comprising their original GR(1) specifications, namely system initial and transition properties. 
We also discuss leasons learned about how to best encode controllers in SPARK for verification, 
examples in which verification found unexpected controller behaviors, and 
caveats related to the interpretation of GR(1) specifications.

%In this paper, we discuss our experience to date using SPARK to implement controllers and to verify them against 
%a subset of properties comprising their original GR(1) specifications, in this case system initial and transition properties. 
%There are many ways to encode synthesized controllers in SPARK, so we describe the encoding that we found to be most efficient for verification. 
%We also describe the contracts and assertions that we needed to generate within the controller implementation so that 
%SPARK could verify the aforementioned properties automatically, i.e. without requiring additional annotations from the user.
%We give some preliminary results on the approximate size of controllers that can be verified and the amount of time needed for verification, 
%using a database of GR(1) specification examples pulled from a variety of sources. 
%Finally, we close with a discussion of certain implementation choices that arise due to environment assumptions encoded in GR(1) specifications, 
%some of which we have handled and some of which we have currently deferred. 
%We also discuss possible approaches for verifying the full set of GR(1) properties, i.e. including liveness.

\keywords{Reactive synthesis \and end-to-end verification \and functional verification.}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Reactive systems must be capable of correctly responding to various inputs, 
e.g. originating from human users or events in the system's operational environment. 
The process of manually designing the control logic for such systems is both time-consuming and error prone. 
An alternative is to use ``correct-by-construction'' synthesis approaches to automatically generate 
the design of a system's control logic directly from specifications, which can 
reduce both design time and the likelihood of errors 
\cite{alur2016compositional}, \cite{fainekos2009temporal}, \cite{guo2014cooperative}, \cite{kupermann2001synthesizing}. 
In general, \emph{synthesis} is the process of automatically generating a design from a specification. 
More specifically, \emph{reactive synthesis} approaches generate designs in the context of an uncontrolled environment, 
assumptions about which are encoded in the specification.
Reactive synthesis approaches tend to have high computational complexity,  
so there is particular interest in synthesis from Generalized Reactivity(1) or GR(1) specifications, 
the complexity of which is only polynomial in the size of the game graph encoded by the specification \cite{bloem2012}.
Synthesis from GR(1) specifications has been used to generate digital circuits \cite{ehlers2012symbolically} 
and controllers for teams of unmanned vehicles \cite{apker2016}, ground robots \cite{kress2007s}, 
software-defined networks \cite{wang2013automated}, and aircraft power distribution systems \cite{xu2012case}, to name a few.

A GR(1) specification $\varphi$ takes the form $\varphi = \varphi^e \limplies \varphi^s$, 
where $\varphi^e$ encodes assumptions about the \emph{environment} in which a system is to operate,
and $\varphi^s$ encodes guarantees the \emph{system} should make under those assumptions \cite{Ehlers2016}. 
More specifically, $\varphi$ takes the form 
$\varphi = (\varphi^e_i \land \varphi^e_t \land \varphi^e_l)  \limplies (\varphi^s_i \land \varphi^s_t \land \varphi^s_l)$,
where $\varphi^e_i$ and $\varphi^s_i$ are \emph{initial} properties, 
$\varphi^e_t$ and $\varphi^s_t$ are \emph{transition} or safety properties, and 
$\varphi^e_l$ and $\varphi^s_l$ are \emph{liveness} properties. 
For inputs in the set $\inputs$ controlled by the environment 
and outputs in the set $\outputs$ produced by the system, terms are:

\vspace{0.5em}

\noindent \begin{xtabular}{p{.045\columnwidth}p{.015\columnwidth}p{.860\columnwidth}}
 $\varphi^e_i$, $\varphi^s_i$ & - & Boolean formulas over $\inputs$ and $\outputs$, respectively, that characterize the initial state of the environment and system.
\end{xtabular}

\noindent \begin{xtabular}{p{.045\columnwidth}p{.015\columnwidth}p{.860\columnwidth}}
 $\varphi^e_t$, $\varphi^s_t$ & - &  Formulas of the form $\bigwedge_{j \in J} \always B_j$, where each $B_j$ is a Boolean combination of variables from $\inputs \cup \outputs$ and expressions of the form $\lnext v$, where $v \in \inputs$ for $\varphi^e_t$ and $v \in \inputs \cup \outputs$ for $\varphi^s_t$. These encode properties that should always hold as well as rules for how inputs and outputs are allowed to change based on current input and output values.
\end{xtabular}

\noindent \begin{xtabular}{p{.045\columnwidth}p{.015\columnwidth}p{.860\columnwidth}}
$\varphi^e_l$, $\varphi^s_l$ & - & Formulas of the form $\bigwedge_{j \in J} \always \eventually B_j$, where each $B_j$ is a Boolean formula over $\inputs \cup \outputs$. These encode properties that should hold infinitely often.
\end{xtabular}

\vspace{0.5em}

\noindent It is assumed that at each time step, the environment chooses an input from $\inputs$, then the system chooses an output from $\outputs$ in response. 
The result of synthesis is a \emph{control protocol} or \emph{strategy} that can be expressed as a Moore machine, 
with each state encoding the most recent input values from the environment and the most recent output values produced in response by the system.

Several tools for GR(1) synthesis are available. 
For example, RATSY %(Requirements Analysis Tool with Synthesis) 
\cite{bloem2010ratsy} has a focus on circuit design and can synthesize designs 
encoded in BLIF, %(Berkeley Logic Interchange Format),
Verilog, and HIF. %(HDL Intermediate Format). 
Similarly, Anzu \cite{jobstmann2007anzu} produces circuit designs in Verilog.
LTLMoP 
%(Linear Temporal Logic MissiOn Planning)  
\cite{finucane2010ltlmop} is focused on control of robots modeled as hybrid systems, 
and it synthesizes designs as hybrid controllers with handler modules to help connect controllers to simulated or real-world systems. 
TuLiP 
%(Temporal Logic Planning) 
\cite{TuLiP2011} has a similar focus and can synthesize controller implementations in Python. 
Slugs 
%(SmalL bUt Complete GROne Synthesizer) 
\cite{Ehlers2016} is architected to allow users to easily tailor synthesis algorithms for specific applications,
 e.g. to optimize criteria such as quick response, cost-optimality, and error-resilience, and it produces mathematical representations of controller designs.
Salty \cite{elliott2019salty} provides a front-end to Slugs that makes specifications easier to write and debug and 
a back-end that turns controller designs into executable sofware implementations in a variety of programming languages.

Though these tools implement synthesis algorithms that are theoretically ``correct-by-construction,'' 
tool implementation errors could still result in errors in synthesized controllers. 
We are therefore interested in ``end-to-end'' verification of synthesized controllers with respect to their original GR(1) specifications. 
Toward this end, we have extended Salty to produce software implementations of synthesized controller designs in SPARK. 
SPARK is both a programming language with a specification language and associated verification toolset \cite{hoang2015spark}. 
Though SPARK aims to perform fully automated verification, often the user must help guide the underlying provers by
annotating the code, e.g. with assertions and loop invariants. 
However, since controller designs synthesized from GR(1) specifications follow a regular structure, it was our hope that we could 
synthesize both the controller logic and the annotations necessary to automatically prove that controllers meet their functional specifications in SPARK. 
To date, we have largely achieved this goal for a subset of properties comprising GR(1) specifiations, 
i.e. system initial and transition properties, for moderately-sized controllers.
In what follows, in \sectref{sec:implementation} we discuss the SPARK implementation. 
In \sectref{sec:caseStudies}, we demonstrate the efficacy of our approach on examples pulled from a variety of sources.
In \sectref{sec:discussion}, we discuss possible approaches for proving liveness properties as well as design choice alternatives, 
e.g. for dealing with environment specifications.
We end with concluding remarks in \sectref{sec:conclusions}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% IMPLEMENTATION and Verification in SPARK
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation and Verification in SPARK}
\label{sec:implementation}

To explain the structure of the controllers we generate in SPARK, consider a simple example of a controller for a traffic light. 
Color changes are triggered in every state in which an input signal's value is true.
Let this input be called $tick$.
The traffic light's color changes from red to green to yellow and back to red, repeating the cycle infinitely. 
Let the output variables then be $red$, $yellow$, and $green$.
The environment specifications are $\varphi^e_i = \top$, $\varphi^e_t = \top$, $\varphi^e_l = \always \eventually tick$, i.e.  
$tick$ can be true or false in the initial state and has no constraints on how it transitions from state to state, but it must be true infinitely often.
The system initial and liveness specifications are $\varphi^s_i = red \land \lnot yellow \land \lnot green$ and $\varphi^s_l =  \always \eventually green$, i.e.
the light starts as red but should infinitely often be green. The system transition specification is
%{\footnotesize
%\begin{align}
%\always & (\lnext ( (red \land \lnot yellow \land \lnot green) \lor (\lnot red \land yellow \land \lnot green) \lor \mbox{} \label{eq:mutex1} \\
%	& \quad \quad \quad (\lnot red \land \lnot yellow \land green)) \land \mbox{}  \label{eq:mutex2} \\
%	& \;\; (red \land \lnext tick \limplies \lnext green) \land (green \land \lnext tick \limplies \lnext yellow) \land \mbox{} \label{eq:change1} \\
%	& \quad \quad \quad (yellow \land \lnext tick \limplies \lnext red) \land \mbox{}  \label{eq:change2} \\
%	& \;\; (red \land \lnext \lnot tick \limplies red) \land (green \land \lnext \lnot tick \limplies green) \land \mbox{} \label{eq:same1} \\
%	& \quad \quad \quad (yellow \land \lnext \lnot tick \limplies yellow) \label{eq:same2})
%\end{align}
%}%
%That is, \eqnref{eq:mutex1} - \eqnref{eq:mutex2} express that the light should only be one color at a time; 
%\eqnref{eq:change1} - \eqnref{eq:change2} that the color should change from red to green to yellow and back to red whenever $tick$ is true; 
%and the color should remain the same whenever $tick$ is false.

{\scriptsize
\begin{align}
\always & (\lnext ( (red \land \lnot yellow \land \lnot green) \lor (\lnot red \land yellow \land \lnot green) \lor (\lnot red \land \lnot yellow \land green)) \land \mbox{}  \label{eq:mutex} \\
	& \; (red \land \lnext tick \limplies \lnext green) \land (green \land \lnext tick \limplies \lnext yellow) \land (yellow \land \lnext tick \limplies \lnext red) \land \mbox{}  \label{eq:change} \\
	& \; (red \land \lnext \lnot tick \limplies red) \land (green \land \lnext \lnot tick \limplies green) \land (yellow \land \lnext \lnot tick \limplies yellow) \label{eq:same})
\end{align}
}


\noindent That is, the light should only be one color at a time \eqnref{eq:mutex}; 
the color should change from red $\rightarrow$ green $\rightarrow$ yellow $\rightarrow$ red $\rightarrow \ldots$ whenever $tick$ is true \eqnref{eq:change}; 
and the color should remain the same whenever $tick$ is false \eqnref{eq:same}.

\begin{figure}
\begin{lstlisting}[language={Ada}, basicstyle=\scriptsize, numbers=left]
package TrafficLight with SPARK_Mode is
  type Controller is private;
  
  type System is record
      red: Boolean; yellow: Boolean; green: Boolean;
    end record;
  
  function Is_Init(C: Controller) return Boolean;
  function Env_Init(tick: Boolean) return Boolean is (True);
  function Sys_Init(S: System) return Boolean is 
    (S.red and not S.yellow and not S.green) with Ghost;
    
  function Env_Trans(C: Controller; tick: Boolean) return Boolean
    with Pre => (not Is_Init(C));
  function Sys_Trans(C: Controller; tick: Boolean; S: System) 
    return Boolean with Pre => (not Is_Init(C)), Ghost;
    
  procedure Move(C: in out Controller; tick: in Boolean; S: out System)
    with 
    Pre => (if Is_Init(C) then Env_Init(tick) else Env_Trans(C, tick)),
    Contract_Cases =>
      (Is_Init(C) => Sys_Init(S) and (not Is_Init(C)),
       others => Sys_Trans(C'Old, tick, S) and (not Is_Init(C)));

private
  function State_To_Input_Mapping(C: Controller) return Boolean
    with Ghost;
  function State_To_Output_Mapping(C: Controller) return Boolean
    with Ghost;
  
  subtype State_Num is Integer range 1 .. 7;
  
  type Controller is record
      State: State_Num := State_Num'Last; tick: Boolean; S: System;
  end record
    with Type_Invariant => (State_To_Input_Mapping(Controller) and 
                            State_To_Output_Mapping(Controller));
      
end TrafficLight;
\end{lstlisting}
  \caption{SPARK specification for a traffic light controller.}
  \label{fig:trafficLightSpec}
\end{figure}

\sloppy{
In SPARK, subunits consist of a specification and a body. 
For each synthesized controller, Salty automatically generates both a specification and body for a package named according to the Salty specification. 
The package specification is shown in \figref{fig:trafficLightSpec}.
Type \lstinline{Controller} encodes a Moore machine suitable for representing the state of a synthesized controller. 
In the public part of the specification (line 2), \lstinline{Controller} is declared as a private type so that the user cannot arbitrarily manipulate its state 
(possibly violating the controller's GR(1) specification). 
In the private part of the specification (lines 34-39), \lstinline{Controller} is a record that stores the controller's internal state number, 
current input value(s), and the current output value(s). 
Its initial state is always the last possible state number. 
Each input and output is of type \lstinline{Boolean}.
When there are multiple inputs or outputs, they are wrapped in a record of type \lstinline{System} (lines 4-7) or \lstinline{Environment}, respectively. 
Here, there is only one input, so it is not wrapped in a record. 
Since controllers are Moore machines, \lstinline{Controller} includes a type invariant (lines 38-39) that specifies that for each internal state, 
there is exactly one set of input values that brought the controller into that state and exactly one set of output values produced in that state. 
Functions \lstinline{State_To_Input_Mapping} and \lstinline{State_To_Output_Mapping} encode lookup tables specifying the input and output value(s) for each state, respectively.
Both of these are declared (lines 27-30) with aspect \lstinline{Ghost}, indicating that they used for proof purposes only, 
i.e. they will create verification conditions related to type \lstinline{Controller} but are not executable. 
The logic for these functions is given in the body (not shown here), but for instance in state 0, \lstinline{State_To_Input_Equivalence} returns \lstinline{False}, 
since \lstinline{tick = False} as the system enters state 0, and \lstinline{State_To_Input_Equivalence} returns \lstinline{System'(red => True, yellow => False, green => False)}, 
since $red$ is True and $yellow$ and $green$ are false as the system enters state 0.
 }

The public function \lstinline{Is_Init} (line 9) checks whether the controller is in its initial state, i.e. no inputs have yet been received. 
The public function \lstinline{Env_Init} (line 10) checks whether input(s) satisfy $\varphi_e^i$. 
It is implemented as an expression function, i.e. the implementation is given directly in the specification and not the body, 
because all terms needed to define it are visible in the public part of the specification. 
In this example, since $\varphi_e^i = \top$ as pulled from the Salty specification, this function always simply returns \lstinline{True}. 
The public function \lstinline{Sys_Init} (lines 11-12) checks whether outputs(s) satisfy $\varphi_s^i$. 
It is implemented as an expression function for the same reason.  
As pulled from the Salty specification, $\varphi^s_i = red \land \lnot yellow \land \lnot green$, so this function returns the value of
the expression \lstinline{S.red and not S.yellow and not S.green}.
But unlike \lstinline{Is_Init} and \lstinline{Env_Init}, it is marked with aspect \lstinline{Ghost}, 
meaning it is ``ghost code'' used only for proof and cannot be executed. 
\lstinline{Is_Init} and \lstinline{Env_Init} are used for proof and are also executable. 
We chose to make these executable for reasons related to the meaning of GR(1) specifications. 
Recall that GR(1) specifications have the form $\varphi_e \limplies \varphi_s$. 
If $\varphi_e$ ever becomes false, i.e. if the environment produces input value(s) that violate $\varphi_e$, then the specification as whole 
is satisfied regardless of whether the system produces output value(s) that satisfy $\varphi_s$. 
In theory, the system in this case could produce arbitrary outputs and still satisy the overall specification. 
In practice, we believe a user would generally want to know that the environment violated its specification, 
so that the user could either choose the system output value(s) explicitly or fall back to some other error handling routine. 
Therefore, a user needs to be able to check inputs with \lstinline{Env_Init} if \lstinline{Is_Init} returns true, 
which is why both are executable.
Public functions \lstinline{Env_Trans} and \lstinline{Sys_Trans} (lines 14-17) check whether the next set of input value(s) and output value(s) 
satisfy $\varphi_e^t$ and $\varphi_s^t$, respectively. 
For the same reasons as above, \lstinline{Env_Trans} is executable but \lstinline{Sys_Trans} is ghost code. 
Note that \lstinline{Env_Trans} has a precondition that the controller must not be in its initial state, 
since $\varphi_e^t$ can depend on both the current and next set of input value(s). 
This precondition is not necessary for \lstinline{Sys_Trans}, since it is not executable, and it will only be used to 
assert properties in cases in which the controller is not in its initial state. 
As with \lstinline{Env_Init} and \lstinline{Sys_Init}, the logic for these functions is pulled from the Salty specification and 
implemented in the body (not shown), since they make use of input and output values stored in the \lstinline{Controller}, whose fields are private.

\begin{figure}
\begin{lstlisting}[language={Ada}, basicstyle=\scriptsize]  
procedure Move(C: in out Controller; tick: in Boolean; S: out System) is
begin
  case C.State is
    when 1 =>
      case tick is
        when False =>
          C.State := 1; 
          C.S.red := True; C.S.yellow := False; C.S.green := False;
        when True =>
          C.State := 3; 
          C.S.red := False; C.S.yellow := False; C.S.green := True;
        when others =>
          raise Program_Error;
      end case;
       ...      
     when 7 =>
      case tick is
        when False =>
          C.State := 1; 
          C.S.red := True; C.S.yellow := False; C.S.green := False;
        when True => 
          C.State := 2; 
          C.S.red := True; C.S.yellow := False; C.S.green := False;
        when others =>
          raise Program_Error;
      end case;
  end case;
  C.tick := tick; S := C.S;
end Move;
\end{lstlisting}
  \caption{The body of the Move procedure.}
  \label{fig:moveBody}
\end{figure}

The public procedure \lstinline{Move} (lines 19-24) transitions a controller based on its current state and 
next set of input value(s), and it produces the next set of output value(s). 
It has a precondition that if the controller is in its initial state, 
inputs must satisfy $\varphi_e^i$; otherwise they must satisfy $\varphi_e^t$.
The aspect \lstinline{Contract_Cases} specifies additional sets of preconditions paired with postconditions, 
where the set of all preconditions must be mutually exclusive and exhaustively cover the entire input space.
The \lstinline{others} keyword can be used to cover the set of all input conditions not covered in any explicit cases of the contract. 
Note that for the left-hand side of each case (left of the \lstinline{=>}), variable names refer to variable values before evaluation of the subprogram; 
for the right-hand side, they refer to variable values after evaluation.
For the right-hand side, the aspect \lstinline{Old} can therefore be used to reference the value of a variable before evaluation of the subprogram. 
Combined with the previous precondition, \lstinline{Contract_Cases} asserts that if the controller is in its initial state, then after execution of \lstinline{Move}, 
the first set of output value(s) produced should satisfy $\varphi_s^i$ and the controller should no longer be in its initial state; 
if it is not in its initial state, then the output value(s) produced should satisfy $\varphi_s^t$, 
evaluated based on the most recent input and output values stored in C'Old, the next input value(s) just provided (in this case in \lstinline{tick}), 
and the next output values just generated (in this case in the record \lstinline{System}). 
This set of contract cases embodies our main proof goal, i.e. verification of system initial and transition properties from the original GR(1) specification for the controller. 


A fragment of the body of \lstinline{Move} is shown in \figref{fig:moveBody}. 
Note that there are cases that can lead to \lstinline{Program_Error}. 
This is because we programmatically use \lstinline{others} to cover all possible input combinations 
that would not be allowed due to $\varphi_e^i$ or $\varphi_e^t$. 
In the traffic light example, they are unnecessary because all possible combinations of input values are 
allowed out of each state. 
In any case, SPARK will prove that that these cases are not reachable.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CASE STUDIES
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Studies}
\label{sec:caseStudies}

To check whether our approach has the potential to produce SPARK controllers that can be automatically verified to satisfy their original system initial and transition specifications, 
we pulled examples of GR(1) specifications from Anzu, LTLMoP, TuLiP, Slugs, Salty, all of which make their examples publically available for download. 
These examples -- including GR(1) specifications, sythesized SPARK packages, and SPARK analysis results -- are now all available in Salty format on the 
Salty GitHub repository\footnote{https://github.com/GaloisInc/salty/}, including the traffic light example of the previous section. 

Many of the examples could be fully proven in SPARK in a matter of seconds.   
However, many examples were surprisingly large, with 10s or even 100s of thousands of states, 
resulting in controller bodies that are several megabytes in some cases. 
Some of these could be analyzed but not fully proven; often, SPARK could prove 99\% of the checks required for functional correctness of the \lstinline{Move} function. 
Others required too much memory to analyze.
\figref{fig:timingResults} shows the amount of time needed to analyze examples as a function of approximate number of states, 
with examples that proved to 99\% marked in red and examples that could not be analyzed set to -1 in red. 
Results were generated on a Linux VM given 24 MB RAM and 4 processors on a MacBook Pro with a 2.9 GHz Intel Core i9 with 32GB RAM.

\begin{figure}
\caption{Timing results for example controllers in SPARK.}
\label{fig:timingResults}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lessons Learned
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Lessons Learned}
\label{sec:lessonsLearned}

Throughout the process of synthesizing and attempting to verify controllers in SPARK, we learned several lessons, 
both about SPARK and about some of the finer points of GR(1) specifications.

In terms of encoding SPARK controllers for verification, we originally tried to 
[James: fill in what we tried to do in our first iteration].
However, using case structures in the \lstinline{Move} procedure was better suited to proof because
[James and/or Joffrey: fill in the reason(s) why case structures are better]

[James and/or Laura: I want to write a little more detail about the next section]
We also found that some examples in our database did not have any inputs, i.e. they essentially amounted to synthesizing a system independent of an environment. 
In that case, we had specifications for a non-existent environment that were vacuous, 
and this was causing SPARK to take an abnormally long amount of time to verify these controllers, given their relatively small size.

We also originally had some examples that resulted in invalid SPARK code. 
In particular, there were cases in the controller that were empty. 
After some investigation, we discovered that in the mathematical representation of the controllers, there were states with no possible successors. 
This is due to the interpretation of GR(1) specifications as a game between the environment and the system. 
Recall that since GR(1) specifications have the form $\varphi_e \limplies \varphi_s$, if the environment violates its specification $\varphi_e$, then the system 
can violate its specification $\varphi_s$ and still satisfy the overall specification. 
States with no successors represent cases in which the system can ``win'' the game by transitioning to a state in which the environment is forced to violate $\varphi_e$. 
In \sectref{sec:implementation}, we stated that we believe a user will generally want to know when the environment violates its specification. 
Therefore, we believe that the best way to handle this would be to return some indication to the user, so they can decide what the system should do or fall back to some other error handling routine, 
which will require some modifications to our SPARK code generator. 
In the meantime, we were essentially able to tighten up these specifications so that there were no such states.
[Laura and/or James: explain why this was happening in our examples. Also check with the VIP example: does this reveal an error in the code synthesized in other languages? It's possible that there are case statements that are "falling through"]

[Joffrey: If there are examples that are still taking an unexplainable amount of time, it'd be nice to have an intuition for why.]

[Joffrey: It would also be nice if there were an intuition for why SPARK is generally able to exactly 99\% of checks for large examples. Is it the "final" form of the post condition that is causing problems?]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}
\label{sec:conclusions}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\newpage
\bibliographystyle{splncs04}
\bibliography{bibfile}

\end{document}
